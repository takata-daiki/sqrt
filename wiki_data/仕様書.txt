◎制作するもの
平方根の計算
入力は整数0～65535(16ビット)
出力は整数部分8ビット、小数部分8ビット
内部的にはもっと計算する？
◆参考のプログラム
int mysqrt(unsigned int x){
  int a = 0, c = 0, y = 0, i = 0, t = x;
  while(t >>= 1){
    ++i;
  }
  for(i += i & 1; i >= 0; i -= 2){
    c = (y << 1 | 1) <= x >> i;
    a = a << 1 | c;
    y = y << 1 | c;
    x -= c * y << i;
    /* if(c){
      x -= y << i;
    } */
    y += c;
  }
  return a;
}

◎モジュール
・命令デコーダ
・ALU
・汎用レジスタ
・フラグレジスタ(Z, S, O)
・プログラムレジスタ
・メモリ
？？？クロック（ポジティブエッジトリガー）

◎デコーダの仕様
　プログラムレジスタで指定されるメモリの内容を読み込み、16ビットの命令として受け付ける
　ニモニック(4ビット)、第一オペランド(4ビット)、第二オペランド(8ビット)に分ける

◎ALUの仕様
　LD, LAD, STR, ADD, SUB, JMP, JZE, HALT 命令を処理
　SL, SR, JMI, NAND, DISP 命令を処理
　ニモニックは4ビット

◎メモリの仕様
　16ビット×256アドレス

◎汎用レジスタの仕様
　16ビット×16個

◎フラグレジスタの仕様
　各1ビット、ALU使用後に条件を満たすものは1、そうでないものは0になる
　Z　答えが0000になるなら1になる
　S　答えが負になるなら1になる
　O　答えがFFFFを超えるなら1になる、またはシフト演算で押し出された値が入る

◎プログラムレジスタ
　16ビット、初期値は0
　プログラムレジスタの下8ビットで指定する場所の命令を実行する
　命令実行後に1増加する、ただしJMP系の命令とHALTの実行後は増加しない
　JMP系の命令で値が変更される

◎命令の仕様
　HALT：0000 （なし）  　　　　  　　　終了
　LD① ：0001 レジスタA レジスタB 　　　レジスタBの内容をレジスタAにコピー
　LD② ：0010 レジスタA メモリアドレス　メモリアドレスの内容をレジスタAにコピー
　LAD ：0011 レジスタA メモリアドレス　メモリアドレスのアドレス値をレジスタAにコピー
　STR ：0100 レジスタA メモリアドレス　レジスタAの内容をメモリアドレスの場所にコピー（注意！）
　ADD ：0101 レジスタA レジスタB 　　　レジスタA＋レジスタBの答えをレジスタAに入れる FFFFを超えるならフラグOを1にする
　SUB ：0110 レジスタA レジスタB 　　　レジスタA－レジスタBの答えをレジスタAに入れる 負になるならフラグSを1にする
　SL  ：0111 レジスタA レジスタB 　　　レジスタAのビットをレジスタBの内容分だけ左へ動かす 一番右(下)の桁は0になる
　SR  ：1000 レジスタA レジスタB 　　　レジスタAのビットをレジスタBの内容分だけ右へ動かす 一番左(上)の桁は0になる
　NAND：1001 レジスタA レジスタB 　　　レジスタA nand レジスタB の答えをレジスタAに入れる
　JMP ：1010 レジスタA メモリアドレス　メモリアドレスのアドレス値をプログラムレジスタにコピー
　JZE ：1011 レジスタA メモリアドレス　フラグZが1なら、メモリアドレスのアドレス値をプログラムレジスタにコピー
　JMI ：1100 レジスタA メモリアドレス　フラグSが1なら、メモリアドレスのアドレス値をプログラムレジスタにコピー
　JOV ：1101 レジスタA メモリアドレス　フラグOが1なら、メモリアドレスのアドレス値をプログラムレジスタにコピー
　RJMP：1110 レジスタA 　　　　  　　　レジスタAの内容をプログラムレジスタにコピーした後、プログラムレジスタの値を1増加する
　DISP：1111 レジスタA レジスタB 　　　レジスタAの下4ビットをレジスタBで指定する7セグメントLEDに出力
※JMP, JZE, JMI, JOV はレジスタAに0を指定しないとき、レジスタAにジャンプ前のアドレスを書き込む

